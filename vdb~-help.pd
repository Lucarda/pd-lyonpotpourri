#N canvas 446 36 728 649 12;
#N canvas 0 22 450 300 (subpatch) 0;
#X array vdb-delay-line 88200 float 2;
#X coords 0 1 88200 -1 100 70 1;
#X restore 339 341 graph;
#X obj 98 232 r vdb-msgs;
#N canvas 289 62 859 761 input-sound 0;
#X obj 52 162 *~;
#X msg 213 47 tempo \$1;
#X floatatom 213 16 5 0 0 0 - vdb-tempo -;
#X floatatom 52 23 5 0 0 0 - - -;
#X obj 52 109 osc~ 450;
#X obj 52 352 *~ 0.5;
#X msg 145 328 0.5;
#X obj 356 27 loadbang;
#X text 466 59 softer envelope;
#X obj 213 108 lyonpotpourri/adsr~;
#X msg 136 363 0;
#X obj 272 376 soundfiler;
#X msg 272 343 write -aiff \$1 vdb-delay-line;
#X obj 272 262 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X obj 272 298 savepanel;
#X text 296 263 if you like what is in the array during infinite hold
\, you can write the array to disk., f 48;
#X msg 356 60 20 20 100 100;
#X obj 52 80 line;
#X msg 52 51 \$1 50;
#X obj 147 445 throw~ vdb-input-sound;
#X obj 213 77 samm~ 60 1;
#X connect 0 0 5 0;
#X connect 1 0 20 0;
#X connect 2 0 1 0;
#X connect 3 0 18 0;
#X connect 4 0 0 0;
#X connect 5 0 19 0;
#X connect 6 0 5 1;
#X connect 7 0 16 0;
#X connect 9 0 0 1;
#X connect 10 0 5 1;
#X connect 12 0 11 0;
#X connect 13 0 14 0;
#X connect 14 0 12 0;
#X connect 16 0 9 0;
#X connect 17 0 4 0;
#X connect 18 0 17 0;
#X connect 20 0 9 0;
#X restore 197 433 pd input-sound;
#N canvas 600 60 550 496 delaytime 0;
#X obj 339 154 *~ 200;
#X obj 339 180 +~ 799;
#X msg 24 167 channel \$1;
#X obj 24 138 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 1
1;
#X obj 24 21 loadbang;
#X floatatom 339 103 5 0 0 0 - vdb-delaychange-speed -;
#X msg 24 68 1;
#X obj 90 232 sig~ 200;
#X text 66 68 select fixed or changing delay time;
#X obj 339 128 osc~ 0.25;
#X obj 90 266 lyonpotpourri/clean_selector~ 2 1000;
#X text 382 105 speed of delay change;
#X text 157 232 fixed delay of 200 ms;
#N canvas 0 23 677 468 infhold-response 0;
#X obj 37 83 r \$0-infhold-tog;
#X obj 37 111 sel 1;
#X obj 37 139 pipe 2000;
#X msg 37 167 0;
#X obj 37 206 outlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X restore 49 105 pd infhold-response;
#X obj 90 299 throw~ vdb-delay-time;
#X floatatom 90 206 5 0 0 0 - vdb-fixed-delaytime -;
#X connect 0 0 1 0;
#X connect 1 0 10 1;
#X connect 2 0 10 0;
#X connect 3 0 2 0;
#X connect 4 0 6 0;
#X connect 5 0 9 0;
#X connect 6 0 3 0;
#X connect 7 0 10 0;
#X connect 9 0 0 0;
#X connect 10 0 14 0;
#X connect 13 0 3 0;
#X connect 15 0 7 0;
#X restore 197 459 pd delaytime;
#X floatatom 371 173 5 -0.9 0.9 2 feedback vdb-feedback -;
#X obj 200 383 hsl 120 15 -0.9 0.9 0 0 vdb-feedback vdb-feedback-in
feedback_amt -2 -8 1 10 -185881 -1 -1 0 1;
#X obj 31 376 lpp-meters;
#N canvas 566 294 520 316 init 0;
#X msg 40 52 \; vdb-feedback-in 0.5 \; vdb-delaychange-speed 0.25 \;
vdb-fixed-delaytime 200 \; vdb-tempo 60;
#X restore 197 511 pd init;
#X text 93 288 args: buffername \, max delay time (ms) \, delay time
\, feedback \, interpolation flag, f 79;
#X obj 31 265 lyonpotpourri/vdb~ vdb-delay-line 2000 1000 0.7 1;
#X obj 23 5 lpp-icon vdb~;
#N canvas 398 94 682 530 array-redraws 0;
#X obj 38 493 s vdb-msgs;
#X msg 38 122 redraw;
#X obj 38 69 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0 1
;
#X obj 38 94 metro 1000;
#X obj 112 189 loadbang;
#X msg 112 270 redraw_array \$1;
#X obj 112 245 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X msg 112 217 0;
#X text 225 270 redraw array on every callback (currently a click-fest)
;
#X obj 264 340 loadbang;
#X obj 264 396 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X msg 264 422 always_update \$1;
#X text 281 404 reattaches buffer on each callback (maybe not necessary)
;
#X msg 264 368 0;
#X text 72 66 redraw once per second \, can still introduce clicks
;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 3 0 1 0;
#X connect 4 0 7 0;
#X connect 5 0 0 0;
#X connect 6 0 5 0;
#X connect 7 0 6 0;
#X connect 9 0 13 0;
#X connect 10 0 11 0;
#X connect 11 0 0 0;
#X connect 13 0 10 0;
#X restore 197 537 pd array-redraws;
#N canvas 600 60 375 355 infinite-hold 0;
#X obj 36 157 s vdb-msgs;
#X msg 36 107 inf_hold \$1;
#X obj 36 24 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0 1
;
#X text 58 27 toggle infinite hold;
#N canvas 0 23 862 612 smoothing 0;
#X obj 40 206 lyonpotpourri/buffet~ vdb-delay-line;
#X obj 40 86 sel 1;
#X obj 40 116 pipe 2000;
#X obj 40 146 t b b;
#X text 202 173 fade clicks at array boundaries \, for infinite hold
;
#X obj 40 56 inlet;
#X obj 166 97 s \$0-infhold-tog;
#X msg 40 176 fadein 20;
#X msg 124 176 fadeout 40;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 8 0;
#X connect 3 1 7 0;
#X connect 5 0 1 0;
#X connect 5 0 6 0;
#X connect 7 0 0 0;
#X connect 8 0 0 0;
#X restore 51 66 pd smoothing;
#X connect 1 0 0 0;
#X connect 2 0 1 0;
#X connect 2 0 4 0;
#X restore 197 485 pd infinite-hold;
#X obj 201 173 catch~ vdb-delay-time;
#X obj 31 173 catch~ vdb-input-sound;
#X text 34 100 [vdb~] treats an array as a delayline with internal
feedback (thus no lower limit on delaytime by vector size).;
#X text 231 36 - a delay line with feedback \, exposed in an array
;
#X connect 1 0 9 0;
#X connect 4 0 9 2;
#X connect 9 0 6 1;
#X connect 9 0 6 0;
#X connect 13 0 9 1;
#X connect 14 0 9 0;
